/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { createAnchorFromTransform, deleteAnchorPersistence, restoreAnchorFromUUID, } from './Anchor';
import { Group, Vector3 } from 'three';
import { createHitTestTargetFromSpace, updateHitTestTarget, } from './HitTestTarget';
import { Plane, updatePlane } from './Plane';
import { RMesh, updateMesh } from './Mesh';
import { updateTransformObject } from './TransformObject';
export class RealityAccelerator {
    constructor(xrManager) {
        this._xrManager = xrManager;
        this._planes = new Set();
        this._meshes = new Set();
        this._anchors = new Set();
        this._hitTestTargets = new Set();
        this._root = new Group();
    }
    get root() {
        return this._root;
    }
    get planes() {
        return this._planes;
    }
    get meshes() {
        return this._meshes;
    }
    get anchors() {
        return this._anchors;
    }
    get hitTestTargets() {
        return this._hitTestTargets;
    }
    get persistentAnchors() {
        return new Set(Array.from(this._anchors).filter((anchor) => anchor.isPersistent));
    }
    update() {
        if (!this._xrManager.isPresenting)
            return;
        const frame = this._xrManager.getFrame();
        const session = this._xrManager.getSession();
        if (session !== this._currentSession) {
            this._currentSession = session !== null && session !== void 0 ? session : undefined;
            this._handleSessionUpdate();
        }
        this._checkPlaneDiff(frame);
        this.planes.forEach((plane) => {
            updatePlane(plane, this._xrManager);
        });
        this._checkMeshDiff(frame);
        this.meshes.forEach((mesh) => {
            updateMesh(mesh, this._xrManager);
        });
        this.anchors.forEach((anchor) => {
            updateTransformObject(anchor, this._xrManager);
        });
        this._hitTestTargets.forEach((hitTestTarget) => {
            updateHitTestTarget(hitTestTarget, this._xrManager);
        });
    }
    async _handleSessionUpdate() {
        this._anchors.forEach((anchor) => {
            this._anchors.delete(anchor);
            this._root.remove(anchor);
        });
        this._hitTestTargets.forEach((hitTestTarget) => {
            this._root.remove(hitTestTarget);
            this._hitTestTargets.delete(hitTestTarget);
        });
    }
    _checkPlaneDiff(frame) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const detectedPlanes = frame.detectedPlanes;
        const newXrPlanes = [];
        detectedPlanes.forEach((xrPlane) => {
            let match = false;
            this._planes.forEach((plane) => {
                if (plane.xrPlane === xrPlane)
                    match = true;
            });
            if (!match)
                newXrPlanes.push(xrPlane);
        });
        const deletedPlanes = [];
        this._planes.forEach((plane) => {
            if (!detectedPlanes.has(plane.xrPlane)) {
                deletedPlanes.push(plane);
            }
        });
        newXrPlanes.forEach((xrPlane) => {
            const plane = new Plane(xrPlane);
            updatePlane(plane, this._xrManager);
            this._root.add(plane);
            if (this.onPlaneAdded) {
                this.onPlaneAdded(plane);
            }
            this._planes.add(plane);
        });
        deletedPlanes.forEach((plane) => {
            if (this.onPlaneDeleted) {
                this.onPlaneDeleted(plane);
            }
            this._root.remove(plane);
            this._planes.delete(plane);
        });
    }
    _checkMeshDiff(frame) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const detectedMeshes = frame.detectedMeshes;
        const newXrMeshes = [];
        detectedMeshes.forEach((xrMesh) => {
            let match = false;
            this._meshes.forEach((mesh) => {
                if (mesh.xrMesh === xrMesh)
                    match = true;
            });
            if (!match)
                newXrMeshes.push(xrMesh);
        });
        const deletedMeshes = [];
        this._meshes.forEach((mesh) => {
            if (!detectedMeshes.has(mesh.xrMesh)) {
                deletedMeshes.push(mesh);
            }
        });
        newXrMeshes.forEach((xrMesh) => {
            const mesh = new RMesh(xrMesh);
            updateMesh(mesh, this._xrManager);
            this._root.add(mesh);
            if (this.onMeshAdded) {
                this.onMeshAdded(mesh);
            }
            this._meshes.add(mesh);
        });
        deletedMeshes.forEach((mesh) => {
            if (this.onMeshDeleted) {
                this.onMeshDeleted(mesh);
            }
            this._root.remove(mesh);
            this._meshes.delete(mesh);
        });
    }
    async createAnchor(position, quaternion, persistent = false) {
        const anchor = await createAnchorFromTransform(this._xrManager, position, quaternion);
        this._root.add(anchor);
        this._anchors.add(anchor);
        if (persistent) {
            await anchor.makePersistent();
        }
        return anchor;
    }
    async deleteAnchor(anchor) {
        if (anchor.isPersistent) {
            await deleteAnchorPersistence(anchor, this._xrManager);
        }
        this._anchors.delete(anchor);
        this._root.remove(anchor);
        anchor.xrAnchor.delete();
    }
    async restorePersistentAnchors() {
        const session = this._xrManager.getSession();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const persistentAnchors = session.persistentAnchors;
        if (!persistentAnchors) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        for (const anchorId of persistentAnchors) {
            const anchor = await restoreAnchorFromUUID(this._xrManager, anchorId);
            this._root.add(anchor);
            this._anchors.add(anchor);
        }
    }
    async createHitTestTargetFromSpace(space, offsetOrigin = new Vector3(0, 0, 0), offsetDirection = new Vector3(0, 0, -1)) {
        const hitTestTarget = await createHitTestTargetFromSpace(this._xrManager, space, offsetOrigin, offsetDirection);
        this._root.add(hitTestTarget);
        this._hitTestTargets.add(hitTestTarget);
        return hitTestTarget;
    }
    async createHitTestTargetFromViewerSpace(offsetOrigin = new Vector3(0, 0, 0), offsetDirection = new Vector3(0, 0, -1)) {
        const session = this._xrManager.getSession();
        if (!session) {
            throw 'renderer.xr.getSession() returned null';
        }
        const viewerSpace = await session.requestReferenceSpace('viewer');
        return await this.createHitTestTargetFromSpace(viewerSpace, offsetOrigin, offsetDirection);
    }
    async createHitTestTargetFromControllerSpace(handedness, offsetOrigin = new Vector3(0, 0, 0), offsetDirection = new Vector3(0, 0, -1)) {
        const session = this._xrManager.getSession();
        if (!session) {
            throw 'renderer.xr.getSession() returned null';
        }
        for (const xrInputSource of session.inputSources) {
            if (xrInputSource.handedness === handedness) {
                return await this.createHitTestTargetFromSpace(xrInputSource.targetRaySpace, offsetOrigin, offsetDirection);
            }
        }
        throw new DOMException('requested XRInputSource cannot be found', 'NotFoundError');
    }
    deleteHitTestTarget(hitTestTarget) {
        hitTestTarget.xrHitTestSource.cancel();
        this._root.remove(hitTestTarget);
        this._hitTestTargets.delete(hitTestTarget);
    }
}
//# sourceMappingURL=RealityAccelerator.js.map