/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { TransformObject } from './TransformObject';
export class Anchor extends TransformObject {
    constructor(xrAnchor, uuid) {
        super(xrAnchor.anchorSpace);
        this.persistenceDeletionPending = false;
        this._xrAnchor = xrAnchor;
        this.anchorID = uuid;
    }
    get xrAnchor() {
        return this._xrAnchor;
    }
    get isPersistent() {
        return this.anchorID != null;
    }
    async makePersistent() {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!this._xrAnchor.requestPersistentHandle) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        else if (this.isPersistent) {
            throw new DOMException('anchor is already persistent', 'InvalidStateError');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.anchorID = await this._xrAnchor.requestPersistentHandle();
    }
    async makeNonPersistent() {
        this.persistenceDeletionPending = true;
    }
}
export const createAnchorFromTransform = async (xrManager, position, quaternion) => {
    const frame = xrManager.getFrame();
    if (!frame.createAnchor) {
        throw 'XRFrame.createAnchor is undefined';
    }
    const refSpace = xrManager.getReferenceSpace();
    if (!refSpace) {
        throw 'renderer.xr.getReferenceSpace() returned null';
    }
    const anchorPose = new XRRigidTransform({
        x: position.x,
        y: position.y,
        z: position.z,
    }, {
        x: quaternion.x,
        y: quaternion.y,
        z: quaternion.z,
        w: quaternion.w,
    });
    const xrAnchor = await frame.createAnchor(anchorPose, refSpace);
    if (!xrAnchor) {
        throw 'XRAnchor creation failed';
    }
    const anchor = new Anchor(xrAnchor);
    return anchor;
};
export const restoreAnchorFromUUID = async (xrManager, uuid) => {
    const session = xrManager.getSession();
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    if (!session.restorePersistentAnchor) {
        throw new DOMException('feature not supported by browser', 'NotSupportedError');
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const xrAnchor = await session.restorePersistentAnchor(uuid);
    const anchor = new Anchor(xrAnchor, uuid);
    return anchor;
};
export const deleteAnchorPersistence = async (anchor, xrManager) => {
    if (anchor.isPersistent) {
        const session = xrManager.getSession();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!session.deletePersistentAnchor) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        await session.deletePersistentAnchor(anchor.anchorID);
        anchor.anchorID = undefined;
    }
};
//# sourceMappingURL=Anchor.js.map