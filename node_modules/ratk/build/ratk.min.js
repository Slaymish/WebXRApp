!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Ratk={},e.THREE)}(this,(function(e,t){"use strict";class r extends t.Group{constructor(e){super(),this.needsUpdate=!0,this._xrSpace=e}get xrSpace(){return this._xrSpace}}const n=new t.Vector3,s=(e,r)=>{const s=r.getFrame(),o=r.getReferenceSpace();if(!o)throw"renderer.xr.getReferenceSpace() returned null";const i=s.getPose(e.xrSpace,o);if(!i)throw"pose is not available";(new t.Matrix4).fromArray(i.transform.matrix).decompose(e.position,e.quaternion,n)};class o extends r{constructor(e,t){super(e.anchorSpace),this.persistenceDeletionPending=!1,this._xrAnchor=e,this.anchorID=t}get xrAnchor(){return this._xrAnchor}get isPersistent(){return null!=this.anchorID}async makePersistent(){if(!this._xrAnchor.requestPersistentHandle)throw new DOMException("feature not supported by browser","NotSupportedError");if(this.isPersistent)throw new DOMException("anchor is already persistent","InvalidStateError");this.anchorID=await this._xrAnchor.requestPersistentHandle()}async makeNonPersistent(){this.persistenceDeletionPending=!0}}const i=async(e,t)=>{const r=e.getSession();if(!r.restorePersistentAnchor)throw new DOMException("feature not supported by browser","NotSupportedError");const n=await r.restorePersistentAnchor(t);return new o(n,t)};class a extends r{constructor(e){super(e.planeSpace),this.needsUpdate=!0,this.lastUpdatedByRATK=-1/0,this.boundingRectangleWidth=0,this.boundingRectangleHeight=0,this._xrPlane=e}get xrPlane(){return this._xrPlane}get orientation(){return this._xrPlane.orientation}get lastUpdated(){return this._xrPlane.lastChangedTime}get semanticLabel(){return this._xrPlane.semanticLabel}}const c=(e,r)=>{if(s(e,r),e.xrPlane.lastChangedTime<=e.lastUpdatedByRATK)return;const n=(e=>{const r=new t.Shape;e.forEach(((e,t)=>{0==t?r.moveTo(e.x,e.z):r.lineTo(e.x,e.z)}));const n=new t.ShapeGeometry(r);return n.rotateX(-Math.PI/2),n})(e.xrPlane.polygon);e.planeMesh?(e.planeMesh.geometry.dispose(),e.planeMesh.geometry=n):(e.planeMesh=new t.Mesh(n,new t.MeshBasicMaterial),e.add(e.planeMesh)),[e.boundingRectangleWidth,e.boundingRectangleHeight]=(e=>{let t=1/0,r=1/0,n=-1/0,s=-1/0;return e.forEach((e=>{t=Math.min(t,e.x),r=Math.min(r,e.z),n=Math.max(n,e.x),s=Math.max(s,e.z)})),[n-t,s-r]})(e.xrPlane.polygon),e.lastUpdatedByRATK=e.xrPlane.lastChangedTime};class h extends r{constructor(e){super(e.meshSpace),this.needsUpdate=!0,this.lastUpdatedByRATK=-1/0,this._xrMesh=e}get xrMesh(){return this._xrMesh}get lastUpdated(){return this._xrMesh.lastChangedTime}get semanticLabel(){return this._xrMesh.semanticLabel}}const d=(e,r)=>{if(s(e,r),e.xrMesh.lastChangedTime<=e.lastUpdatedByRATK)return;const n=new t.BufferGeometry;n.setAttribute("position",new t.BufferAttribute(e.xrMesh.vertices,3)),n.setIndex(new t.BufferAttribute(e.xrMesh.indices,1)),e.meshMesh?(e.meshMesh.geometry.dispose(),e.meshMesh.geometry=n):(e.meshMesh=new t.Mesh(n,new t.MeshBasicMaterial),e.add(e.meshMesh)),e.lastUpdatedByRATK=e.xrMesh.lastChangedTime};class l extends t.Group{constructor(e){super(),this.hitTestResultValid=!1,this.hitTestResults=[],this._xrHitTestSource=e}get xrHitTestSource(){return this._xrHitTestSource}}class u{static convertToARButton(e,t,r={}){function n(){var t;e.onclick=null,e.classList.add("ar-not-supported"),e.textContent=null!==(t=r.XR_NOT_SUPPORTED_TEXT)&&void 0!==t?t:"AR NOT SUPPORTED",r.onUnsupported&&r.onUnsupported()}navigator.xr?navigator.xr.isSessionSupported("immersive-ar").then((function(s){s?function(){var n,s,o;const i={requiredFeatures:null!==(n=r.requiredFeatures)&&void 0!==n?n:[],optionalFeatures:null!==(s=r.optionalFeatures)&&void 0!==s?s:[]};let a;async function c(n){var s;n.addEventListener("end",h),await t.xr.setSession(n),e.textContent=null!==(s=r.LEAVE_XR_TEXT)&&void 0!==s?s:"EXIT AR",a=n,r.onSessionStarted&&r.onSessionStarted(a)}function h(){var t;a&&(a.removeEventListener("end",h),e.textContent=null!==(t=r.ENTER_XR_TEXT)&&void 0!==t?t:"ENTER AR",r.onSessionEnded&&r.onSessionEnded(a),a=null)}e.textContent=null!==(o=r.ENTER_XR_TEXT)&&void 0!==o?o:"ENTER AR",e.onclick=function(){a?a.end():navigator.xr&&navigator.xr.requestSession("immersive-ar",i).then(c).catch((e=>{r.onFeaturesUnsupported&&r.onFeaturesUnsupported(e)}))},r.onSupported&&r.onSupported()}():n()})).catch((function(t){var n;e.onclick=null,e.classList.add("ar-not-allowed"),e.textContent=null!==(n=r.XR_NOT_ALLOWED_TEXT)&&void 0!==n?n:"AR NOT ALLOWED",console.warn("Exception when trying to call xr.isSessionSupported",t),r.onNotAllowed&&r.onNotAllowed(t)})):n()}static createButton(e,t={}){const r=document.createElement("button");return u.convertToARButton(r,e,t),r}}class p{static convertToVRButton(e,t,r={}){function n(){var t;e.onclick=null,e.classList.add("vr-not-supported"),e.textContent=null!==(t=r.XR_NOT_SUPPORTED_TEXT)&&void 0!==t?t:"VR NOT SUPPORTED",r.onUnsupported&&r.onUnsupported()}navigator.xr?navigator.xr.isSessionSupported("immersive-vr").then((function(s){s?function(){var n,s,o;const i={requiredFeatures:null!==(n=r.requiredFeatures)&&void 0!==n?n:[],optionalFeatures:null!==(s=r.optionalFeatures)&&void 0!==s?s:["local-floor"]};let a;async function c(n){var s;n.addEventListener("end",h),await t.xr.setSession(n),e.textContent=null!==(s=r.LEAVE_XR_TEXT)&&void 0!==s?s:"EXIT VR",a=n,r.onSessionStarted&&r.onSessionStarted(a)}function h(){var t;a&&(a.removeEventListener("end",h),e.textContent=null!==(t=r.ENTER_XR_TEXT)&&void 0!==t?t:"ENTER VR",r.onSessionEnded&&r.onSessionEnded(a),a=null)}e.textContent=null!==(o=r.ENTER_XR_TEXT)&&void 0!==o?o:"ENTER VR",e.onclick=function(){a?a.end():navigator.xr&&navigator.xr.requestSession("immersive-vr",i).then(c).catch((e=>{r.onFeaturesUnsupported&&r.onFeaturesUnsupported(e)})),r.onSupported&&r.onSupported()}}():n(),s&&p.xrSessionIsGranted&&e.click()})).catch((function(t){var n;e.onclick=null,e.classList.add("vr-not-allowed"),e.textContent=null!==(n=r.XR_NOT_ALLOWED_TEXT)&&void 0!==n?n:"VR NOT ALLOWED",console.warn("Exception when trying to call xr.isSessionSupported",t),r.onNotAllowed&&r.onNotAllowed(t)})):n()}static registerSessionGrantedListener(){if(navigator.xr){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{p.xrSessionIsGranted=!0}))}}static createButton(e,t={}){const r=document.createElement("button");return p.convertToVRButton(r,e,t),r}}p.xrSessionIsGranted=!1,p.registerSessionGrantedListener(),e.ARButton=u,e.Anchor=o,e.HitTestTarget=l,e.Plane=a,e.RMesh=h,e.RealityAccelerator=class{constructor(e){this._xrManager=e,this._planes=new Set,this._meshes=new Set,this._anchors=new Set,this._hitTestTargets=new Set,this._root=new t.Group}get root(){return this._root}get planes(){return this._planes}get meshes(){return this._meshes}get anchors(){return this._anchors}get hitTestTargets(){return this._hitTestTargets}get persistentAnchors(){return new Set(Array.from(this._anchors).filter((e=>e.isPersistent)))}update(){if(!this._xrManager.isPresenting)return;const e=this._xrManager.getFrame(),t=this._xrManager.getSession();t!==this._currentSession&&(this._currentSession=null!=t?t:void 0,this._handleSessionUpdate()),this._checkPlaneDiff(e),this.planes.forEach((e=>{c(e,this._xrManager)})),this._checkMeshDiff(e),this.meshes.forEach((e=>{d(e,this._xrManager)})),this.anchors.forEach((e=>{s(e,this._xrManager)})),this._hitTestTargets.forEach((e=>{((e,t)=>{const r=t.getFrame(),n=t.getReferenceSpace();if(!n)throw"renderer.xr.getReferenceSpace() returned null";if(e.hitTestResults=r.getHitTestResults(e.xrHitTestSource),e.hitTestResultValid=!1,e.hitTestResults.length>0){const t=e.hitTestResults[0].getPose(n);if(!t)throw"hitPose is not available";e.position.set(t.transform.position.x,t.transform.position.y,t.transform.position.z),e.quaternion.set(t.transform.orientation.x,t.transform.orientation.y,t.transform.orientation.z,t.transform.orientation.w),e.hitTestResultValid=!0}})(e,this._xrManager)}))}async _handleSessionUpdate(){this._anchors.forEach((e=>{this._anchors.delete(e),this._root.remove(e)})),this._hitTestTargets.forEach((e=>{this._root.remove(e),this._hitTestTargets.delete(e)}))}_checkPlaneDiff(e){const t=e.detectedPlanes,r=[];t.forEach((e=>{let t=!1;this._planes.forEach((r=>{r.xrPlane===e&&(t=!0)})),t||r.push(e)}));const n=[];this._planes.forEach((e=>{t.has(e.xrPlane)||n.push(e)})),r.forEach((e=>{const t=new a(e);c(t,this._xrManager),this._root.add(t),this.onPlaneAdded&&this.onPlaneAdded(t),this._planes.add(t)})),n.forEach((e=>{this.onPlaneDeleted&&this.onPlaneDeleted(e),this._root.remove(e),this._planes.delete(e)}))}_checkMeshDiff(e){const t=e.detectedMeshes,r=[];t.forEach((e=>{let t=!1;this._meshes.forEach((r=>{r.xrMesh===e&&(t=!0)})),t||r.push(e)}));const n=[];this._meshes.forEach((e=>{t.has(e.xrMesh)||n.push(e)})),r.forEach((e=>{const t=new h(e);d(t,this._xrManager),this._root.add(t),this.onMeshAdded&&this.onMeshAdded(t),this._meshes.add(t)})),n.forEach((e=>{this.onMeshDeleted&&this.onMeshDeleted(e),this._root.remove(e),this._meshes.delete(e)}))}async createAnchor(e,t,r=!1){const n=await(async(e,t,r)=>{const n=e.getFrame();if(!n.createAnchor)throw"XRFrame.createAnchor is undefined";const s=e.getReferenceSpace();if(!s)throw"renderer.xr.getReferenceSpace() returned null";const i=new XRRigidTransform({x:t.x,y:t.y,z:t.z},{x:r.x,y:r.y,z:r.z,w:r.w}),a=await n.createAnchor(i,s);if(!a)throw"XRAnchor creation failed";return new o(a)})(this._xrManager,e,t);return this._root.add(n),this._anchors.add(n),r&&await n.makePersistent(),n}async deleteAnchor(e){e.isPersistent&&await(async(e,t)=>{if(e.isPersistent){const r=t.getSession();if(!r.deletePersistentAnchor)throw new DOMException("feature not supported by browser","NotSupportedError");await r.deletePersistentAnchor(e.anchorID),e.anchorID=void 0}})(e,this._xrManager),this._anchors.delete(e),this._root.remove(e),e.xrAnchor.delete()}async restorePersistentAnchors(){const e=this._xrManager.getSession().persistentAnchors;if(!e)throw new DOMException("feature not supported by browser","NotSupportedError");for(const t of e){const e=await i(this._xrManager,t);this._root.add(e),this._anchors.add(e)}}async createHitTestTargetFromSpace(e,r=new t.Vector3(0,0,0),n=new t.Vector3(0,0,-1)){const s=await(async(e,t,r,n)=>{const s=e.getSession();if(!s)throw"renderer.xr.getSession() returned null";if(!s.requestHitTestSource)throw"session.requestHitTestSource is undefined";const o=await s.requestHitTestSource({space:t,offsetRay:new XRRay({x:r.x,y:r.y,z:r.z,w:1},{x:n.x,y:n.y,z:n.z,w:0})});if(!o)throw"XRHitTestSource request failed";return new l(o)})(this._xrManager,e,r,n);return this._root.add(s),this._hitTestTargets.add(s),s}async createHitTestTargetFromViewerSpace(e=new t.Vector3(0,0,0),r=new t.Vector3(0,0,-1)){const n=this._xrManager.getSession();if(!n)throw"renderer.xr.getSession() returned null";const s=await n.requestReferenceSpace("viewer");return await this.createHitTestTargetFromSpace(s,e,r)}async createHitTestTargetFromControllerSpace(e,r=new t.Vector3(0,0,0),n=new t.Vector3(0,0,-1)){const s=this._xrManager.getSession();if(!s)throw"renderer.xr.getSession() returned null";for(const t of s.inputSources)if(t.handedness===e)return await this.createHitTestTargetFromSpace(t.targetRaySpace,r,n);throw new DOMException("requested XRInputSource cannot be found","NotFoundError")}deleteHitTestTarget(e){e.xrHitTestSource.cancel(),this._root.remove(e),this._hitTestTargets.delete(e)}},e.TransformObject=r,e.VRButton=p,Object.defineProperty(e,"__esModule",{value:!0})}));
