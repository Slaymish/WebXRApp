(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('three')) :
    typeof define === 'function' && define.amd ? define(['exports', 'three'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Ratk = {}, global.THREE));
})(this, (function (exports, three) { 'use strict';

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class TransformObject extends three.Group {
        constructor(xrSpace) {
            super();
            this.needsUpdate = true;
            this._xrSpace = xrSpace;
        }
        get xrSpace() {
            return this._xrSpace;
        }
    }
    const tempVec3 = new three.Vector3();
    const updateTransformObject = (transformObject, xrManager) => {
        const frame = xrManager.getFrame();
        const refSpace = xrManager.getReferenceSpace();
        if (!refSpace) {
            throw 'renderer.xr.getReferenceSpace() returned null';
        }
        const pose = frame.getPose(transformObject.xrSpace, refSpace);
        if (!pose) {
            throw 'pose is not available';
        }
        new three.Matrix4()
            .fromArray(pose.transform.matrix)
            .decompose(transformObject.position, transformObject.quaternion, tempVec3);
    };

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class Anchor extends TransformObject {
        constructor(xrAnchor, uuid) {
            super(xrAnchor.anchorSpace);
            this.persistenceDeletionPending = false;
            this._xrAnchor = xrAnchor;
            this.anchorID = uuid;
        }
        get xrAnchor() {
            return this._xrAnchor;
        }
        get isPersistent() {
            return this.anchorID != null;
        }
        async makePersistent() {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            if (!this._xrAnchor.requestPersistentHandle) {
                throw new DOMException('feature not supported by browser', 'NotSupportedError');
            }
            else if (this.isPersistent) {
                throw new DOMException('anchor is already persistent', 'InvalidStateError');
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            this.anchorID = await this._xrAnchor.requestPersistentHandle();
        }
        async makeNonPersistent() {
            this.persistenceDeletionPending = true;
        }
    }
    const createAnchorFromTransform = async (xrManager, position, quaternion) => {
        const frame = xrManager.getFrame();
        if (!frame.createAnchor) {
            throw 'XRFrame.createAnchor is undefined';
        }
        const refSpace = xrManager.getReferenceSpace();
        if (!refSpace) {
            throw 'renderer.xr.getReferenceSpace() returned null';
        }
        const anchorPose = new XRRigidTransform({
            x: position.x,
            y: position.y,
            z: position.z,
        }, {
            x: quaternion.x,
            y: quaternion.y,
            z: quaternion.z,
            w: quaternion.w,
        });
        const xrAnchor = await frame.createAnchor(anchorPose, refSpace);
        if (!xrAnchor) {
            throw 'XRAnchor creation failed';
        }
        const anchor = new Anchor(xrAnchor);
        return anchor;
    };
    const restoreAnchorFromUUID = async (xrManager, uuid) => {
        const session = xrManager.getSession();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        if (!session.restorePersistentAnchor) {
            throw new DOMException('feature not supported by browser', 'NotSupportedError');
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const xrAnchor = await session.restorePersistentAnchor(uuid);
        const anchor = new Anchor(xrAnchor, uuid);
        return anchor;
    };
    const deleteAnchorPersistence = async (anchor, xrManager) => {
        if (anchor.isPersistent) {
            const session = xrManager.getSession();
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            if (!session.deletePersistentAnchor) {
                throw new DOMException('feature not supported by browser', 'NotSupportedError');
            }
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            await session.deletePersistentAnchor(anchor.anchorID);
            anchor.anchorID = undefined;
        }
    };

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class Plane extends TransformObject {
        constructor(xrPlane) {
            super(xrPlane.planeSpace);
            this.needsUpdate = true;
            this.lastUpdatedByRATK = -Infinity;
            this.boundingRectangleWidth = 0;
            this.boundingRectangleHeight = 0;
            this._xrPlane = xrPlane;
        }
        get xrPlane() {
            return this._xrPlane;
        }
        get orientation() {
            return this._xrPlane.orientation;
        }
        get lastUpdated() {
            return this._xrPlane.lastChangedTime;
        }
        get semanticLabel() {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            return this._xrPlane.semanticLabel;
        }
    }
    const createGeometryFromPolygon = (polygon) => {
        const planeShape = new three.Shape();
        polygon.forEach((point, i) => {
            if (i == 0) {
                planeShape.moveTo(point.x, point.z);
            }
            else {
                planeShape.lineTo(point.x, point.z);
            }
        });
        const geometry = new three.ShapeGeometry(planeShape);
        geometry.rotateX(-Math.PI / 2);
        return geometry;
    };
    const calculateBoundingRectangleDimension = (polygon) => {
        let minx = Infinity;
        let minz = Infinity;
        let maxx = -Infinity;
        let maxz = -Infinity;
        polygon.forEach((point) => {
            minx = Math.min(minx, point.x);
            minz = Math.min(minz, point.z);
            maxx = Math.max(maxx, point.x);
            maxz = Math.max(maxz, point.z);
        });
        return [maxx - minx, maxz - minz];
    };
    const updatePlane = (plane, xrManager) => {
        updateTransformObject(plane, xrManager);
        if (plane.xrPlane.lastChangedTime <= plane.lastUpdatedByRATK)
            return;
        const planeGeometry = createGeometryFromPolygon(plane.xrPlane.polygon);
        if (plane.planeMesh) {
            plane.planeMesh.geometry.dispose();
            plane.planeMesh.geometry = planeGeometry;
        }
        else {
            plane.planeMesh = new three.Mesh(planeGeometry, new three.MeshBasicMaterial());
            plane.add(plane.planeMesh);
        }
        [plane.boundingRectangleWidth, plane.boundingRectangleHeight] =
            calculateBoundingRectangleDimension(plane.xrPlane.polygon);
        plane.lastUpdatedByRATK = plane.xrPlane.lastChangedTime;
    };

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class RMesh extends TransformObject {
        constructor(xrMesh) {
            super(xrMesh.meshSpace);
            this.needsUpdate = true;
            this.lastUpdatedByRATK = -Infinity;
            this._xrMesh = xrMesh;
        }
        get xrMesh() {
            return this._xrMesh;
        }
        get lastUpdated() {
            return this._xrMesh.lastChangedTime;
        }
        get semanticLabel() {
            return this._xrMesh.semanticLabel;
        }
    }
    const updateMesh = (mesh, xrManager) => {
        updateTransformObject(mesh, xrManager);
        if (mesh.xrMesh.lastChangedTime <= mesh.lastUpdatedByRATK)
            return;
        const geometry = new three.BufferGeometry();
        geometry.setAttribute('position', new three.BufferAttribute(mesh.xrMesh.vertices, 3));
        geometry.setIndex(new three.BufferAttribute(mesh.xrMesh.indices, 1));
        if (mesh.meshMesh) {
            mesh.meshMesh.geometry.dispose();
            mesh.meshMesh.geometry = geometry;
        }
        else {
            mesh.meshMesh = new three.Mesh(geometry, new three.MeshBasicMaterial());
            mesh.add(mesh.meshMesh);
        }
        mesh.lastUpdatedByRATK = mesh.xrMesh.lastChangedTime;
    };

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class HitTestTarget extends three.Group {
        constructor(xrHitTestSource) {
            super();
            this.hitTestResultValid = false;
            this.hitTestResults = [];
            this._xrHitTestSource = xrHitTestSource;
        }
        get xrHitTestSource() {
            return this._xrHitTestSource;
        }
    }
    const updateHitTestTarget = (hitTestTarget, xrManager) => {
        const frame = xrManager.getFrame();
        const refSpace = xrManager.getReferenceSpace();
        if (!refSpace) {
            throw 'renderer.xr.getReferenceSpace() returned null';
        }
        hitTestTarget.hitTestResults = frame.getHitTestResults(hitTestTarget.xrHitTestSource);
        hitTestTarget.hitTestResultValid = false;
        if (hitTestTarget.hitTestResults.length > 0) {
            const hitPose = hitTestTarget.hitTestResults[0].getPose(refSpace);
            if (!hitPose) {
                throw 'hitPose is not available';
            }
            hitTestTarget.position.set(hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z);
            hitTestTarget.quaternion.set(hitPose.transform.orientation.x, hitPose.transform.orientation.y, hitPose.transform.orientation.z, hitPose.transform.orientation.w);
            hitTestTarget.hitTestResultValid = true;
        }
    };
    const createHitTestTargetFromSpace = async (xrManager, space, offsetOrigin, offsetDirection) => {
        const session = xrManager.getSession();
        if (!session) {
            throw 'renderer.xr.getSession() returned null';
        }
        if (!session.requestHitTestSource) {
            throw 'session.requestHitTestSource is undefined';
        }
        const xrHitTestSource = await session.requestHitTestSource({
            space: space,
            offsetRay: new XRRay({
                x: offsetOrigin.x,
                y: offsetOrigin.y,
                z: offsetOrigin.z,
                w: 1,
            }, {
                x: offsetDirection.x,
                y: offsetDirection.y,
                z: offsetDirection.z,
                w: 0,
            }),
        });
        if (!xrHitTestSource) {
            throw 'XRHitTestSource request failed';
        }
        const hitTestTarget = new HitTestTarget(xrHitTestSource);
        return hitTestTarget;
    };

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class RealityAccelerator {
        constructor(xrManager) {
            this._xrManager = xrManager;
            this._planes = new Set();
            this._meshes = new Set();
            this._anchors = new Set();
            this._hitTestTargets = new Set();
            this._root = new three.Group();
        }
        get root() {
            return this._root;
        }
        get planes() {
            return this._planes;
        }
        get meshes() {
            return this._meshes;
        }
        get anchors() {
            return this._anchors;
        }
        get hitTestTargets() {
            return this._hitTestTargets;
        }
        get persistentAnchors() {
            return new Set(Array.from(this._anchors).filter((anchor) => anchor.isPersistent));
        }
        update() {
            if (!this._xrManager.isPresenting)
                return;
            const frame = this._xrManager.getFrame();
            const session = this._xrManager.getSession();
            if (session !== this._currentSession) {
                this._currentSession = session !== null && session !== void 0 ? session : undefined;
                this._handleSessionUpdate();
            }
            this._checkPlaneDiff(frame);
            this.planes.forEach((plane) => {
                updatePlane(plane, this._xrManager);
            });
            this._checkMeshDiff(frame);
            this.meshes.forEach((mesh) => {
                updateMesh(mesh, this._xrManager);
            });
            this.anchors.forEach((anchor) => {
                updateTransformObject(anchor, this._xrManager);
            });
            this._hitTestTargets.forEach((hitTestTarget) => {
                updateHitTestTarget(hitTestTarget, this._xrManager);
            });
        }
        async _handleSessionUpdate() {
            this._anchors.forEach((anchor) => {
                this._anchors.delete(anchor);
                this._root.remove(anchor);
            });
            this._hitTestTargets.forEach((hitTestTarget) => {
                this._root.remove(hitTestTarget);
                this._hitTestTargets.delete(hitTestTarget);
            });
        }
        _checkPlaneDiff(frame) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const detectedPlanes = frame.detectedPlanes;
            const newXrPlanes = [];
            detectedPlanes.forEach((xrPlane) => {
                let match = false;
                this._planes.forEach((plane) => {
                    if (plane.xrPlane === xrPlane)
                        match = true;
                });
                if (!match)
                    newXrPlanes.push(xrPlane);
            });
            const deletedPlanes = [];
            this._planes.forEach((plane) => {
                if (!detectedPlanes.has(plane.xrPlane)) {
                    deletedPlanes.push(plane);
                }
            });
            newXrPlanes.forEach((xrPlane) => {
                const plane = new Plane(xrPlane);
                updatePlane(plane, this._xrManager);
                this._root.add(plane);
                if (this.onPlaneAdded) {
                    this.onPlaneAdded(plane);
                }
                this._planes.add(plane);
            });
            deletedPlanes.forEach((plane) => {
                if (this.onPlaneDeleted) {
                    this.onPlaneDeleted(plane);
                }
                this._root.remove(plane);
                this._planes.delete(plane);
            });
        }
        _checkMeshDiff(frame) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const detectedMeshes = frame.detectedMeshes;
            const newXrMeshes = [];
            detectedMeshes.forEach((xrMesh) => {
                let match = false;
                this._meshes.forEach((mesh) => {
                    if (mesh.xrMesh === xrMesh)
                        match = true;
                });
                if (!match)
                    newXrMeshes.push(xrMesh);
            });
            const deletedMeshes = [];
            this._meshes.forEach((mesh) => {
                if (!detectedMeshes.has(mesh.xrMesh)) {
                    deletedMeshes.push(mesh);
                }
            });
            newXrMeshes.forEach((xrMesh) => {
                const mesh = new RMesh(xrMesh);
                updateMesh(mesh, this._xrManager);
                this._root.add(mesh);
                if (this.onMeshAdded) {
                    this.onMeshAdded(mesh);
                }
                this._meshes.add(mesh);
            });
            deletedMeshes.forEach((mesh) => {
                if (this.onMeshDeleted) {
                    this.onMeshDeleted(mesh);
                }
                this._root.remove(mesh);
                this._meshes.delete(mesh);
            });
        }
        async createAnchor(position, quaternion, persistent = false) {
            const anchor = await createAnchorFromTransform(this._xrManager, position, quaternion);
            this._root.add(anchor);
            this._anchors.add(anchor);
            if (persistent) {
                await anchor.makePersistent();
            }
            return anchor;
        }
        async deleteAnchor(anchor) {
            if (anchor.isPersistent) {
                await deleteAnchorPersistence(anchor, this._xrManager);
            }
            this._anchors.delete(anchor);
            this._root.remove(anchor);
            anchor.xrAnchor.delete();
        }
        async restorePersistentAnchors() {
            const session = this._xrManager.getSession();
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            const persistentAnchors = session.persistentAnchors;
            if (!persistentAnchors) {
                throw new DOMException('feature not supported by browser', 'NotSupportedError');
            }
            for (const anchorId of persistentAnchors) {
                const anchor = await restoreAnchorFromUUID(this._xrManager, anchorId);
                this._root.add(anchor);
                this._anchors.add(anchor);
            }
        }
        async createHitTestTargetFromSpace(space, offsetOrigin = new three.Vector3(0, 0, 0), offsetDirection = new three.Vector3(0, 0, -1)) {
            const hitTestTarget = await createHitTestTargetFromSpace(this._xrManager, space, offsetOrigin, offsetDirection);
            this._root.add(hitTestTarget);
            this._hitTestTargets.add(hitTestTarget);
            return hitTestTarget;
        }
        async createHitTestTargetFromViewerSpace(offsetOrigin = new three.Vector3(0, 0, 0), offsetDirection = new three.Vector3(0, 0, -1)) {
            const session = this._xrManager.getSession();
            if (!session) {
                throw 'renderer.xr.getSession() returned null';
            }
            const viewerSpace = await session.requestReferenceSpace('viewer');
            return await this.createHitTestTargetFromSpace(viewerSpace, offsetOrigin, offsetDirection);
        }
        async createHitTestTargetFromControllerSpace(handedness, offsetOrigin = new three.Vector3(0, 0, 0), offsetDirection = new three.Vector3(0, 0, -1)) {
            const session = this._xrManager.getSession();
            if (!session) {
                throw 'renderer.xr.getSession() returned null';
            }
            for (const xrInputSource of session.inputSources) {
                if (xrInputSource.handedness === handedness) {
                    return await this.createHitTestTargetFromSpace(xrInputSource.targetRaySpace, offsetOrigin, offsetDirection);
                }
            }
            throw new DOMException('requested XRInputSource cannot be found', 'NotFoundError');
        }
        deleteHitTestTarget(hitTestTarget) {
            hitTestTarget.xrHitTestSource.cancel();
            this._root.remove(hitTestTarget);
            this._hitTestTargets.delete(hitTestTarget);
        }
    }

    /**
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    class ARButton {
        static convertToARButton(button, renderer, options = {}) {
            function showEnterAR() {
                var _a, _b, _c;
                const sessionInit = {
                    requiredFeatures: (_a = options.requiredFeatures) !== null && _a !== void 0 ? _a : [],
                    optionalFeatures: (_b = options.optionalFeatures) !== null && _b !== void 0 ? _b : [],
                };
                let currentSession;
                async function onSessionStarted(session) {
                    var _a;
                    session.addEventListener('end', onSessionEnded);
                    await renderer.xr.setSession(session);
                    button.textContent = (_a = options.LEAVE_XR_TEXT) !== null && _a !== void 0 ? _a : 'EXIT AR';
                    currentSession = session;
                    if (options.onSessionStarted) {
                        options.onSessionStarted(currentSession);
                    }
                }
                function onSessionEnded() {
                    var _a;
                    if (currentSession) {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = (_a = options.ENTER_XR_TEXT) !== null && _a !== void 0 ? _a : 'ENTER AR';
                        if (options.onSessionEnded) {
                            options.onSessionEnded(currentSession);
                        }
                        currentSession = null;
                    }
                }
                button.textContent = (_c = options.ENTER_XR_TEXT) !== null && _c !== void 0 ? _c : 'ENTER AR';
                button.onclick = function () {
                    if (!currentSession) {
                        if (navigator.xr) {
                            navigator.xr
                                .requestSession('immersive-ar', sessionInit)
                                .then(onSessionStarted)
                                .catch((reason) => {
                                if (options.onFeaturesUnsupported) {
                                    options.onFeaturesUnsupported(reason);
                                }
                            });
                        }
                    }
                    else {
                        currentSession.end();
                    }
                };
                if (options.onSupported) {
                    options.onSupported();
                }
            }
            function showARNotSupported() {
                var _a;
                button.onclick = null;
                button.classList.add('ar-not-supported');
                button.textContent = (_a = options.XR_NOT_SUPPORTED_TEXT) !== null && _a !== void 0 ? _a : 'AR NOT SUPPORTED';
                if (options.onUnsupported) {
                    options.onUnsupported();
                }
            }
            function showARNotAllowed(exception) {
                var _a;
                button.onclick = null;
                button.classList.add('ar-not-allowed');
                button.textContent = (_a = options.XR_NOT_ALLOWED_TEXT) !== null && _a !== void 0 ? _a : 'AR NOT ALLOWED';
                console.warn('Exception when trying to call xr.isSessionSupported', exception);
                if (options.onNotAllowed) {
                    options.onNotAllowed(exception);
                }
            }
            if (navigator.xr) {
                navigator.xr
                    .isSessionSupported('immersive-ar')
                    .then(function (supported) {
                    supported ? showEnterAR() : showARNotSupported();
                })
                    .catch(showARNotAllowed);
            }
            else {
                showARNotSupported();
            }
        }
        static createButton(renderer, options = {}) {
            const button = document.createElement('button');
            ARButton.convertToARButton(button, renderer, options);
            return button;
        }
    }
    class VRButton {
        static convertToVRButton(button, renderer, options = {}) {
            function showEnterVR() {
                var _a, _b, _c;
                const sessionInit = {
                    requiredFeatures: (_a = options.requiredFeatures) !== null && _a !== void 0 ? _a : [],
                    optionalFeatures: (_b = options.optionalFeatures) !== null && _b !== void 0 ? _b : ['local-floor'],
                };
                let currentSession;
                async function onSessionStarted(session) {
                    var _a;
                    session.addEventListener('end', onSessionEnded);
                    await renderer.xr.setSession(session);
                    button.textContent = (_a = options.LEAVE_XR_TEXT) !== null && _a !== void 0 ? _a : 'EXIT VR';
                    currentSession = session;
                    if (options.onSessionStarted)
                        options.onSessionStarted(currentSession);
                }
                function onSessionEnded() {
                    var _a;
                    if (currentSession) {
                        currentSession.removeEventListener('end', onSessionEnded);
                        button.textContent = (_a = options.ENTER_XR_TEXT) !== null && _a !== void 0 ? _a : 'ENTER VR';
                        if (options.onSessionEnded)
                            options.onSessionEnded(currentSession);
                        currentSession = null;
                    }
                }
                button.textContent = (_c = options.ENTER_XR_TEXT) !== null && _c !== void 0 ? _c : 'ENTER VR';
                button.onclick = function () {
                    if (!currentSession) {
                        if (navigator.xr) {
                            navigator.xr
                                .requestSession('immersive-vr', sessionInit)
                                .then(onSessionStarted)
                                .catch((reason) => {
                                if (options.onFeaturesUnsupported) {
                                    options.onFeaturesUnsupported(reason);
                                }
                            });
                        }
                    }
                    else {
                        currentSession.end();
                    }
                    if (options.onSupported) {
                        options.onSupported();
                    }
                };
            }
            function showWebXRNotFound() {
                var _a;
                button.onclick = null;
                button.classList.add('vr-not-supported');
                button.textContent = (_a = options.XR_NOT_SUPPORTED_TEXT) !== null && _a !== void 0 ? _a : 'VR NOT SUPPORTED';
                if (options.onUnsupported)
                    options.onUnsupported();
            }
            function showVRNotAllowed(exception) {
                var _a;
                button.onclick = null;
                button.classList.add('vr-not-allowed');
                button.textContent = (_a = options.XR_NOT_ALLOWED_TEXT) !== null && _a !== void 0 ? _a : 'VR NOT ALLOWED';
                console.warn('Exception when trying to call xr.isSessionSupported', exception);
                if (options.onNotAllowed)
                    options.onNotAllowed(exception);
            }
            if (navigator.xr) {
                navigator.xr
                    .isSessionSupported('immersive-vr')
                    .then(function (supported) {
                    supported ? showEnterVR() : showWebXRNotFound();
                    if (supported && VRButton.xrSessionIsGranted) {
                        button.click();
                    }
                })
                    .catch(showVRNotAllowed);
            }
            else {
                showWebXRNotFound();
            }
        }
        static registerSessionGrantedListener() {
            if (navigator.xr) {
                // WebXRViewer (based on Firefox) has a bug where addEventListener
                // throws a silent exception and aborts execution entirely.
                if (/WebXRViewer\//i.test(navigator.userAgent))
                    return;
                navigator.xr.addEventListener('sessiongranted', () => {
                    VRButton.xrSessionIsGranted = true;
                });
            }
        }
        static createButton(renderer, options = {}) {
            const button = document.createElement('button');
            VRButton.convertToVRButton(button, renderer, options);
            return button;
        }
    }
    VRButton.xrSessionIsGranted = false;
    VRButton.registerSessionGrantedListener();

    exports.ARButton = ARButton;
    exports.Anchor = Anchor;
    exports.HitTestTarget = HitTestTarget;
    exports.Plane = Plane;
    exports.RMesh = RMesh;
    exports.RealityAccelerator = RealityAccelerator;
    exports.TransformObject = TransformObject;
    exports.VRButton = VRButton;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
