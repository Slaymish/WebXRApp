import{Vector3 as e,Group as t,Matrix4 as n,Mesh as s,MeshBasicMaterial as r,Shape as o,ShapeGeometry as i,BufferGeometry as a,BufferAttribute as h}from"three";class c extends t{constructor(e){super(),this.needsUpdate=!0,this._xrSpace=e}get xrSpace(){return this._xrSpace}}const d=new e,l=(e,t)=>{const s=t.getFrame(),r=t.getReferenceSpace();if(!r)throw"renderer.xr.getReferenceSpace() returned null";const o=s.getPose(e.xrSpace,r);if(!o)throw"pose is not available";(new n).fromArray(o.transform.matrix).decompose(e.position,e.quaternion,d)};class u extends c{constructor(e,t){super(e.anchorSpace),this.persistenceDeletionPending=!1,this._xrAnchor=e,this.anchorID=t}get xrAnchor(){return this._xrAnchor}get isPersistent(){return null!=this.anchorID}async makePersistent(){if(!this._xrAnchor.requestPersistentHandle)throw new DOMException("feature not supported by browser","NotSupportedError");if(this.isPersistent)throw new DOMException("anchor is already persistent","InvalidStateError");this.anchorID=await this._xrAnchor.requestPersistentHandle()}async makeNonPersistent(){this.persistenceDeletionPending=!0}}const p=async(e,t)=>{const n=e.getSession();if(!n.restorePersistentAnchor)throw new DOMException("feature not supported by browser","NotSupportedError");const s=await n.restorePersistentAnchor(t);return new u(s,t)};class x extends c{constructor(e){super(e.planeSpace),this.needsUpdate=!0,this.lastUpdatedByRATK=-1/0,this.boundingRectangleWidth=0,this.boundingRectangleHeight=0,this._xrPlane=e}get xrPlane(){return this._xrPlane}get orientation(){return this._xrPlane.orientation}get lastUpdated(){return this._xrPlane.lastChangedTime}get semanticLabel(){return this._xrPlane.semanticLabel}}const g=(e,t)=>{if(l(e,t),e.xrPlane.lastChangedTime<=e.lastUpdatedByRATK)return;const n=(e=>{const t=new o;e.forEach(((e,n)=>{0==n?t.moveTo(e.x,e.z):t.lineTo(e.x,e.z)}));const n=new i(t);return n.rotateX(-Math.PI/2),n})(e.xrPlane.polygon);e.planeMesh?(e.planeMesh.geometry.dispose(),e.planeMesh.geometry=n):(e.planeMesh=new s(n,new r),e.add(e.planeMesh)),[e.boundingRectangleWidth,e.boundingRectangleHeight]=(e=>{let t=1/0,n=1/0,s=-1/0,r=-1/0;return e.forEach((e=>{t=Math.min(t,e.x),n=Math.min(n,e.z),s=Math.max(s,e.x),r=Math.max(r,e.z)})),[s-t,r-n]})(e.xrPlane.polygon),e.lastUpdatedByRATK=e.xrPlane.lastChangedTime};class T extends c{constructor(e){super(e.meshSpace),this.needsUpdate=!0,this.lastUpdatedByRATK=-1/0,this._xrMesh=e}get xrMesh(){return this._xrMesh}get lastUpdated(){return this._xrMesh.lastChangedTime}get semanticLabel(){return this._xrMesh.semanticLabel}}const _=(e,t)=>{if(l(e,t),e.xrMesh.lastChangedTime<=e.lastUpdatedByRATK)return;const n=new a;n.setAttribute("position",new h(e.xrMesh.vertices,3)),n.setIndex(new h(e.xrMesh.indices,1)),e.meshMesh?(e.meshMesh.geometry.dispose(),e.meshMesh.geometry=n):(e.meshMesh=new s(n,new r),e.add(e.meshMesh)),e.lastUpdatedByRATK=e.xrMesh.lastChangedTime};class f extends t{constructor(e){super(),this.hitTestResultValid=!1,this.hitTestResults=[],this._xrHitTestSource=e}get xrHitTestSource(){return this._xrHitTestSource}}class S{constructor(e){this._xrManager=e,this._planes=new Set,this._meshes=new Set,this._anchors=new Set,this._hitTestTargets=new Set,this._root=new t}get root(){return this._root}get planes(){return this._planes}get meshes(){return this._meshes}get anchors(){return this._anchors}get hitTestTargets(){return this._hitTestTargets}get persistentAnchors(){return new Set(Array.from(this._anchors).filter((e=>e.isPersistent)))}update(){if(!this._xrManager.isPresenting)return;const e=this._xrManager.getFrame(),t=this._xrManager.getSession();t!==this._currentSession&&(this._currentSession=null!=t?t:void 0,this._handleSessionUpdate()),this._checkPlaneDiff(e),this.planes.forEach((e=>{g(e,this._xrManager)})),this._checkMeshDiff(e),this.meshes.forEach((e=>{_(e,this._xrManager)})),this.anchors.forEach((e=>{l(e,this._xrManager)})),this._hitTestTargets.forEach((e=>{((e,t)=>{const n=t.getFrame(),s=t.getReferenceSpace();if(!s)throw"renderer.xr.getReferenceSpace() returned null";if(e.hitTestResults=n.getHitTestResults(e.xrHitTestSource),e.hitTestResultValid=!1,e.hitTestResults.length>0){const t=e.hitTestResults[0].getPose(s);if(!t)throw"hitPose is not available";e.position.set(t.transform.position.x,t.transform.position.y,t.transform.position.z),e.quaternion.set(t.transform.orientation.x,t.transform.orientation.y,t.transform.orientation.z,t.transform.orientation.w),e.hitTestResultValid=!0}})(e,this._xrManager)}))}async _handleSessionUpdate(){this._anchors.forEach((e=>{this._anchors.delete(e),this._root.remove(e)})),this._hitTestTargets.forEach((e=>{this._root.remove(e),this._hitTestTargets.delete(e)}))}_checkPlaneDiff(e){const t=e.detectedPlanes,n=[];t.forEach((e=>{let t=!1;this._planes.forEach((n=>{n.xrPlane===e&&(t=!0)})),t||n.push(e)}));const s=[];this._planes.forEach((e=>{t.has(e.xrPlane)||s.push(e)})),n.forEach((e=>{const t=new x(e);g(t,this._xrManager),this._root.add(t),this.onPlaneAdded&&this.onPlaneAdded(t),this._planes.add(t)})),s.forEach((e=>{this.onPlaneDeleted&&this.onPlaneDeleted(e),this._root.remove(e),this._planes.delete(e)}))}_checkMeshDiff(e){const t=e.detectedMeshes,n=[];t.forEach((e=>{let t=!1;this._meshes.forEach((n=>{n.xrMesh===e&&(t=!0)})),t||n.push(e)}));const s=[];this._meshes.forEach((e=>{t.has(e.xrMesh)||s.push(e)})),n.forEach((e=>{const t=new T(e);_(t,this._xrManager),this._root.add(t),this.onMeshAdded&&this.onMeshAdded(t),this._meshes.add(t)})),s.forEach((e=>{this.onMeshDeleted&&this.onMeshDeleted(e),this._root.remove(e),this._meshes.delete(e)}))}async createAnchor(e,t,n=!1){const s=await(async(e,t,n)=>{const s=e.getFrame();if(!s.createAnchor)throw"XRFrame.createAnchor is undefined";const r=e.getReferenceSpace();if(!r)throw"renderer.xr.getReferenceSpace() returned null";const o=new XRRigidTransform({x:t.x,y:t.y,z:t.z},{x:n.x,y:n.y,z:n.z,w:n.w}),i=await s.createAnchor(o,r);if(!i)throw"XRAnchor creation failed";return new u(i)})(this._xrManager,e,t);return this._root.add(s),this._anchors.add(s),n&&await s.makePersistent(),s}async deleteAnchor(e){e.isPersistent&&await(async(e,t)=>{if(e.isPersistent){const n=t.getSession();if(!n.deletePersistentAnchor)throw new DOMException("feature not supported by browser","NotSupportedError");await n.deletePersistentAnchor(e.anchorID),e.anchorID=void 0}})(e,this._xrManager),this._anchors.delete(e),this._root.remove(e),e.xrAnchor.delete()}async restorePersistentAnchors(){const e=this._xrManager.getSession().persistentAnchors;if(!e)throw new DOMException("feature not supported by browser","NotSupportedError");for(const t of e){const e=await p(this._xrManager,t);this._root.add(e),this._anchors.add(e)}}async createHitTestTargetFromSpace(t,n=new e(0,0,0),s=new e(0,0,-1)){const r=await(async(e,t,n,s)=>{const r=e.getSession();if(!r)throw"renderer.xr.getSession() returned null";if(!r.requestHitTestSource)throw"session.requestHitTestSource is undefined";const o=await r.requestHitTestSource({space:t,offsetRay:new XRRay({x:n.x,y:n.y,z:n.z,w:1},{x:s.x,y:s.y,z:s.z,w:0})});if(!o)throw"XRHitTestSource request failed";return new f(o)})(this._xrManager,t,n,s);return this._root.add(r),this._hitTestTargets.add(r),r}async createHitTestTargetFromViewerSpace(t=new e(0,0,0),n=new e(0,0,-1)){const s=this._xrManager.getSession();if(!s)throw"renderer.xr.getSession() returned null";const r=await s.requestReferenceSpace("viewer");return await this.createHitTestTargetFromSpace(r,t,n)}async createHitTestTargetFromControllerSpace(t,n=new e(0,0,0),s=new e(0,0,-1)){const r=this._xrManager.getSession();if(!r)throw"renderer.xr.getSession() returned null";for(const e of r.inputSources)if(e.handedness===t)return await this.createHitTestTargetFromSpace(e.targetRaySpace,n,s);throw new DOMException("requested XRInputSource cannot be found","NotFoundError")}deleteHitTestTarget(e){e.xrHitTestSource.cancel(),this._root.remove(e),this._hitTestTargets.delete(e)}}class w{static convertToARButton(e,t,n={}){function s(){var t;e.onclick=null,e.classList.add("ar-not-supported"),e.textContent=null!==(t=n.XR_NOT_SUPPORTED_TEXT)&&void 0!==t?t:"AR NOT SUPPORTED",n.onUnsupported&&n.onUnsupported()}navigator.xr?navigator.xr.isSessionSupported("immersive-ar").then((function(r){r?function(){var s,r,o;const i={requiredFeatures:null!==(s=n.requiredFeatures)&&void 0!==s?s:[],optionalFeatures:null!==(r=n.optionalFeatures)&&void 0!==r?r:[]};let a;async function h(s){var r;s.addEventListener("end",c),await t.xr.setSession(s),e.textContent=null!==(r=n.LEAVE_XR_TEXT)&&void 0!==r?r:"EXIT AR",a=s,n.onSessionStarted&&n.onSessionStarted(a)}function c(){var t;a&&(a.removeEventListener("end",c),e.textContent=null!==(t=n.ENTER_XR_TEXT)&&void 0!==t?t:"ENTER AR",n.onSessionEnded&&n.onSessionEnded(a),a=null)}e.textContent=null!==(o=n.ENTER_XR_TEXT)&&void 0!==o?o:"ENTER AR",e.onclick=function(){a?a.end():navigator.xr&&navigator.xr.requestSession("immersive-ar",i).then(h).catch((e=>{n.onFeaturesUnsupported&&n.onFeaturesUnsupported(e)}))},n.onSupported&&n.onSupported()}():s()})).catch((function(t){var s;e.onclick=null,e.classList.add("ar-not-allowed"),e.textContent=null!==(s=n.XR_NOT_ALLOWED_TEXT)&&void 0!==s?s:"AR NOT ALLOWED",console.warn("Exception when trying to call xr.isSessionSupported",t),n.onNotAllowed&&n.onNotAllowed(t)})):s()}static createButton(e,t={}){const n=document.createElement("button");return w.convertToARButton(n,e,t),n}}class E{static convertToVRButton(e,t,n={}){function s(){var t;e.onclick=null,e.classList.add("vr-not-supported"),e.textContent=null!==(t=n.XR_NOT_SUPPORTED_TEXT)&&void 0!==t?t:"VR NOT SUPPORTED",n.onUnsupported&&n.onUnsupported()}navigator.xr?navigator.xr.isSessionSupported("immersive-vr").then((function(r){r?function(){var s,r,o;const i={requiredFeatures:null!==(s=n.requiredFeatures)&&void 0!==s?s:[],optionalFeatures:null!==(r=n.optionalFeatures)&&void 0!==r?r:["local-floor"]};let a;async function h(s){var r;s.addEventListener("end",c),await t.xr.setSession(s),e.textContent=null!==(r=n.LEAVE_XR_TEXT)&&void 0!==r?r:"EXIT VR",a=s,n.onSessionStarted&&n.onSessionStarted(a)}function c(){var t;a&&(a.removeEventListener("end",c),e.textContent=null!==(t=n.ENTER_XR_TEXT)&&void 0!==t?t:"ENTER VR",n.onSessionEnded&&n.onSessionEnded(a),a=null)}e.textContent=null!==(o=n.ENTER_XR_TEXT)&&void 0!==o?o:"ENTER VR",e.onclick=function(){a?a.end():navigator.xr&&navigator.xr.requestSession("immersive-vr",i).then(h).catch((e=>{n.onFeaturesUnsupported&&n.onFeaturesUnsupported(e)})),n.onSupported&&n.onSupported()}}():s(),r&&E.xrSessionIsGranted&&e.click()})).catch((function(t){var s;e.onclick=null,e.classList.add("vr-not-allowed"),e.textContent=null!==(s=n.XR_NOT_ALLOWED_TEXT)&&void 0!==s?s:"VR NOT ALLOWED",console.warn("Exception when trying to call xr.isSessionSupported",t),n.onNotAllowed&&n.onNotAllowed(t)})):s()}static registerSessionGrantedListener(){if(navigator.xr){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",(()=>{E.xrSessionIsGranted=!0}))}}static createButton(e,t={}){const n=document.createElement("button");return E.convertToVRButton(n,e,t),n}}E.xrSessionIsGranted=!1,E.registerSessionGrantedListener();export{w as ARButton,u as Anchor,f as HitTestTarget,x as Plane,T as RMesh,S as RealityAccelerator,c as TransformObject,E as VRButton};
